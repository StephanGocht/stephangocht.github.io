<script type="text/javascript">
<!--
// QuickSearch script for JabRef HTML export 
// Version: 3.0
//
// Copyright (c) 2006-2011, Mark Schenk
//
// This software is distributed under a Creative Commons Attribution 3.0 License
// http://creativecommons.org/licenses/by/3.0/
//
// Features:
// - intuitive find-as-you-type searching
//    ~ case insensitive
//    ~ ignore diacritics (optional)
//
// - search with/without Regular Expressions
// - match BibTeX key
//

// Search settings
var searchAbstract = true;	// search in abstract
var searchComment = true;	// search in comment

var noSquiggles = true; 	// ignore diacritics when searching
var searchRegExp = false; 	// enable RegExp searches


if (window.addEventListener) {
	window.addEventListener("load",initSearch,false); }
else if (window.attachEvent) {
	window.attachEvent("onload", initSearch); }

function initSearch() {
	// check for quick search table and searchfield
	if (!document.getElementById('qs_table')||!document.getElementById('quicksearch')) { return; }

	// load all the rows and sort into arrays
	loadTableData();
	
	//find the query field
	qsfield = document.getElementById('qs_field');

	// previous search term; used for speed optimisation
	prevSearch = '';

	//find statistics location
	stats = document.getElementById('stat');
	setStatistics(-1);
	
	// set up preferences
	initPreferences();

	// shows the searchfield
	document.getElementById('quicksearch').style.display = 'block';
	document.getElementById('qs_field').onkeyup = quickSearch;
}

function loadTableData() {
	// find table and appropriate rows
	searchTable = document.getElementById('qs_table');
	var allRows = searchTable.getElementsByTagName('tbody')[0].getElementsByTagName('tr');

	// split all rows into entryRows and infoRows (e.g. abstract, comment, bibtex)
	entryRows = new Array(); infoRows = new Array(); absRows = new Array(); revRows = new Array();

	// get data from each row
	entryRowsData = new Array(); absRowsData = new Array(); revRowsData = new Array(); 
	
	BibTeXKeys = new Array();
	
	for (var i=0, k=0, j=0; i<allRows.length;i++) {
		if (allRows[i].className.match(/entry/)) {
			entryRows[j] = allRows[i];
			entryRowsData[j] = stripDiacritics(getTextContent(allRows[i]));
			allRows[i].id ? BibTeXKeys[j] = allRows[i].id : allRows[i].id = 'autokey_'+j;
			j ++;
		} else {
			infoRows[k++] = allRows[i];
			// check for abstract/comment
			if (allRows[i].className.match(/abstract/)) {
				absRows.push(allRows[i]);
				absRowsData[j-1] = stripDiacritics(getTextContent(allRows[i]));
			} else if (allRows[i].className.match(/comment/)) {
				revRows.push(allRows[i]);
				revRowsData[j-1] = stripDiacritics(getTextContent(allRows[i]));
			}
		}
	}
	//number of entries and rows
	numEntries = entryRows.length;
	numInfo = infoRows.length;
	numAbs = absRows.length;
	numRev = revRows.length;
}

function quickSearch(){
	
	tInput = qsfield;

	if (tInput.value.length == 0) {
		showAll();
		setStatistics(-1);
		qsfield.className = '';
		return;
	} else {
		t = stripDiacritics(tInput.value);

		if(!searchRegExp) { t = escapeRegExp(t); }
			
		// only search for valid RegExp
		try {
			textRegExp = new RegExp(t,"i");
			closeAllInfo();
			qsfield.className = '';
		}
			catch(err) {
			prevSearch = tInput.value;
			qsfield.className = 'invalidsearch';
			return;
		}
	}
	
	// count number of hits
	var hits = 0;

	// start looping through all entry rows
	for (var i = 0; cRow = entryRows[i]; i++){

		// only show search the cells if it isn't already hidden OR if the search term is getting shorter, then search all
		if(cRow.className.indexOf('noshow')==-1 || tInput.value.length <= prevSearch.length){
			var found = false; 

			if (entryRowsData[i].search(textRegExp) != -1 || BibTeXKeys[i].search(textRegExp) != -1){ 
				found = true;
			} else {
				if(searchAbstract && absRowsData[i]!=undefined) {
					if (absRowsData[i].search(textRegExp) != -1){ found=true; } 
				}
				if(searchComment && revRowsData[i]!=undefined) {
					if (revRowsData[i].search(textRegExp) != -1){ found=true; } 
				}
			}
			
			if (found){
				cRow.className = 'entry show';
				hits++;
			} else {
				cRow.className = 'entry noshow';
			}
		}
	}

	// update statistics
	setStatistics(hits)
	
	// set previous search value
	prevSearch = tInput.value;
}


// Strip Diacritics from text
// http://stackoverflow.com/questions/990904/javascript-remove-accents-in-strings

// String containing replacement characters for stripping accents 
var stripstring = 
    'AAAAAAACEEEEIIII'+
    'DNOOOOO.OUUUUY..'+
    'aaaaaaaceeeeiiii'+
    'dnooooo.ouuuuy.y'+
    'AaAaAaCcCcCcCcDd'+
    'DdEeEeEeEeEeGgGg'+
    'GgGgHhHhIiIiIiIi'+
    'IiIiJjKkkLlLlLlL'+
    'lJlNnNnNnnNnOoOo'+
    'OoOoRrRrRrSsSsSs'+
    'SsTtTtTtUuUuUuUu'+
    'UuUuWwYyYZzZzZz.';

function stripDiacritics(str){

    if(noSquiggles==false){
        return str;
    }

    var answer='';
    for(var i=0;i<str.length;i++){
        var ch=str[i];
        var chindex=ch.charCodeAt(0)-192;   // Index of character code in the strip string
        if(chindex>=0 && chindex<stripstring.length){
            // Character is within our table, so we can strip the accent...
            var outch=stripstring.charAt(chindex);
            // ...unless it was shown as a '.'
            if(outch!='.')ch=outch;
        }
        answer+=ch;
    }
    return answer;
}

// http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
// NOTE: must escape every \ in the export code because of the JabRef Export...
function escapeRegExp(str) {
  return str.replace(/[-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

function toggleInfo(articleid,info) {

	var entry = document.getElementById(articleid);
	var abs = document.getElementById('abs_'+articleid);
	var rev = document.getElementById('rev_'+articleid);
	var bib = document.getElementById('bib_'+articleid);
	
	if (abs && info == 'abstract') {
		abs.className.indexOf('noshow') == -1?abs.className = 'abstract noshow':abs.className = 'abstract show';
	} else if (rev && info == 'comment') {
		rev.className.indexOf('noshow') == -1?rev.className = 'comment noshow':rev.className = 'comment show';
	} else if (bib && info == 'bibtex') {
		bib.className.indexOf('noshow') == -1?bib.className = 'bibtex noshow':bib.className = 'bibtex show';
	} else { 
		return;
	}

	// check if one or the other is available
	var revshow; var absshow; var bibshow;
	(abs && abs.className.indexOf('noshow') == -1)? absshow = true: absshow = false;
	(rev && rev.className.indexOf('noshow') == -1)? revshow = true: revshow = false;	
	(bib && bib.className.indexOf('noshow') == -1)? bibshow = true: bibshow = false;
	
	// highlight original entry
	if(entry) {
		if (revshow || absshow || bibshow) {
		entry.className = 'entry highlight show';
		} else {
		entry.className = 'entry show';
		}
	}
	
	// When there's a combination of abstract/comment/bibtex showing, need to add class for correct styling
	if(absshow) {
		(revshow||bibshow)?abs.className = 'abstract nextshow':abs.className = 'abstract';
	} 
	if (revshow) {
		bibshow?rev.className = 'comment nextshow': rev.className = 'comment';
	}	
	
}

function setStatistics (hits) {
	if(hits < 0) { hits=numEntries; }
	if(stats) { stats.firstChild.data = hits + '/' + numEntries}
}

function getTextContent(node) {
	// Function written by Arve Bersvendsen
	// http://www.virtuelvis.com
	
	if (node.nodeType == 3) {
	return node.nodeValue;
	} // text node
	if (node.nodeType == 1 && node.className != "infolinks") { // element node
	var text = [];
	for (var chld = node.firstChild;chld;chld=chld.nextSibling) {
		text.push(getTextContent(chld));
	}
	return text.join("");
	} return ""; // some other node, won't contain text nodes.
}

function showAll(){
	closeAllInfo();
	for (var i = 0; i < numEntries; i++){ entryRows[i].className = 'entry show'; }
}

function closeAllInfo(){
	for (var i=0; i < numInfo; i++){
		if (infoRows[i].className.indexOf('noshow') ==-1) {
			infoRows[i].className = infoRows[i].className + ' noshow';
		}
	}
}

function clearQS() {
	qsfield.value = '';
	showAll();
}

function redoQS(){
	showAll();
	quickSearch(qsfield);
}

function updateSetting(obj){
	var option = obj.id;
	var checked = obj.value;

	switch(option)
	 {
	 case "opt_searchAbs":
	   searchAbstract=!searchAbstract;
	   redoQS();
	   break;
	 case "opt_searchComment":
	   searchComment=!searchComment;
	   redoQS();
	   break;
	 case "opt_useRegExp":
	   searchRegExp=!searchRegExp;
	   redoQS();
	   break;
	 case "opt_noAccents":
	   noSquiggles=!noSquiggles;
	   loadTableData();
	   redoQS();
	   break;
	 }
}

function initPreferences(){
	if(searchAbstract){document.getElementById("opt_searchAbs").checked = true;}
	if(searchComment){document.getElementById("opt_searchComment").checked = true;}
	if(noSquiggles){document.getElementById("opt_noAccents").checked = true;}
	if(searchRegExp){document.getElementById("opt_useRegExp").checked = true;}
	
	if(numAbs==0) {document.getElementById("opt_searchAbs").parentNode.style.display = 'none';}
	if(numRev==0) {document.getElementById("opt_searchComment").parentNode.style.display = 'none';}	
}

function toggleSettings(){
	var togglebutton = document.getElementById('showsettings');
	var settings = document.getElementById('settings');
	
	if(settings.className == "hidden"){
		settings.className = "show";
		togglebutton.innerText = "close settings";
		togglebutton.textContent = "close settings";
	}else{
		settings.className = "hidden";
		togglebutton.innerText = "settings...";		
		togglebutton.textContent = "settings...";
	}
}

-->
</script>
<style type="text/css">
body { background-color: white; font-family: Arial, sans-serif; font-size: 13px; line-height: 1.2; padding: 1em; color: #2E2E2E; width: 50em; margin: auto auto; }

form#quicksearch { width: auto; border-style: solid; border-color: gray; border-width: 1px 0px; padding: 0.7em 0.5em; display:none; position:relative; }
span#searchstat {padding-left: 1em;}

div#settings { margin-top:0.7em; /* border-bottom: 1px transparent solid; background-color: #efefef; border: 1px grey solid; */ }
div#settings ul {margin: 0; padding: 0; }
div#settings li {margin: 0; padding: 0 1em 0 0; display: inline; list-style: none; }
div#settings li + li { border-left: 2px #efefef solid; padding-left: 0.5em;}
div#settings input { margin-bottom: 0px;}

div#settings.hidden {display:none;}

#showsettings { border: 1px grey solid; padding: 0 0.5em; float:right; line-height: 1.6em; text-align: right; }
#showsettings:hover { cursor: pointer; }

.invalidsearch { background-color: red; }
input[type="button"] { background-color: #efefef; border: 1px #2E2E2E solid;}

table { border: 1px gray none; width: 100%; empty-cells: show; border-spacing: 0em 0.1em; margin: 1em 0em; }
th, td { border: none; padding: 0.5em; vertical-align: top; text-align: justify; }

td a { color: navy; text-decoration: none; }
td a:hover  { text-decoration: underline; }

tr.noshow { display: none;}
tr.highlight td { background-color: #EFEFEF; border-top: 2px #2E2E2E solid; font-weight: bold; }
tr.abstract td, tr.comment td, tr.bibtex td { background-color: #EFEFEF; text-align: justify; border-bottom: 2px #2E2E2E solid; }
tr.nextshow td { border-bottom-style: none; }

tr.bibtex pre { width: 100%; overflow: auto; white-space: pre-wrap;}
p.infolinks { margin: 0.3em 0em 0em 0em; padding: 0px; }

@media print {
	p.infolinks, #qs_settings, #quicksearch, t.bibtex { display: none !important; }
	tr { page-break-inside: avoid; }
}
</style>

<form action="" id="quicksearch">
<input type="text" id="qs_field" autocomplete="off" placeholder="Type to search..." /> <input type="button" onclick="clearQS()" value="clear" />
<span id="searchstat">Matching entries: <span id="stat">0</span></span>
<div id="showsettings" onclick="toggleSettings()">settings...</div>
<div id="settings" class="hidden">
<ul>
<li><input type="checkbox" class="search_setting" id="opt_searchAbs" onchange="updateSetting(this)"><label for="opt_searchAbs"> include abstract</label></li>
<li><input type="checkbox" class="search_setting" id="opt_searchComment" onchange="updateSetting(this)"><label for="opt_searchComment"> include comment</label></li>
<li><input type="checkbox" class="search_setting" id="opt_useRegExp" onchange="updateSetting(this)"><label for="opt_useRegExp"> use RegExp</label></li>
<li><input type="checkbox" class="search_setting" id="opt_noAccents" onchange="updateSetting(this)"><label for="opt_noAccents"> ignore accents</label></li>
</ul>
</div>
</form>
<table id="qs_table" border="1">
<tbody>
<tr id="GN21CertifyingParity" class="entry">
	<td>Gocht S and Nordström J (2021), <i>"Certifying Parity Reasoning Efficiently Using Pseudo-Boolean Proofs"</i>, In Proceedings of the AAAI Conference on Artificial Intelligence.  Vol. 35(5), pp. 3768-3777.
	<p class="infolinks">[<a href="javascript:toggleInfo('GN21CertifyingParity','abstract')">Abstract</a>] [<a href="javascript:toggleInfo('GN21CertifyingParity','bibtex')">BibTeX</a>] [<a href="https://ojs.aaai.org/index.php/AAAI/article/view/16494" target="_blank">URL</a>]</p>
	</td>
</tr>
<tr id="abs_GN21CertifyingParity" class="abstract noshow">
	<td><b>Abstract</b>: The dramatic improvements in combinatorial optimization algorithms<br>over the last decades have had a major impact in artificial<br>intelligence, operations research, and beyond, but the output of<br>current state-of-the-art solvers is often hard to verify and is<br>sometimes wrong. For Boolean satisfiability (SAT) solvers proof<br>logging has been introduced as a way to certify correctness, but the<br>methods used seem hard to generalize to stronger paradigms. What is<br>more, even for enhanced SAT techniques such as parity (XOR) reasoning,<br>cardinality detection, and symmetry handling, it has remained beyond<br>reach to design practically efficient proofs in the standard DRAT<br>format. In this work, we show how to instead use pseudo-Boolean<br>inequalities with extension variables to concisely justify XOR<br>reasoning. Our experimental evaluation of a SAT solver integration<br>shows a dramatic decrease in proof logging and verification time<br>compared to existing DRAT methods. Since our method is a strict<br>generalization of DRAT, and readily lends itself to expressing also<br>0-1 programming and even constraint programming problems, we hope this<br>work points the way towards a unified approach for efficient<br>machine-verifiable proofs for a rich class of combinatorial<br>optimization paradigms.</td>
</tr>
<tr id="bib_GN21CertifyingParity" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@inproceedings{GN21CertifyingParity,
  author = {Stephan Gocht and Jakob Nordström},
  title = {Certifying Parity Reasoning Efficiently Using Pseudo-Boolean Proofs},
  booktitle = {Proceedings of the AAAI Conference on Artificial Intelligence},
  year = {2021},
  volume = {35},
  number = {5},
  pages = {3768--3777},
  url = {https://ojs.aaai.org/index.php/AAAI/article/view/16494}
}
</pre></td>
</tr>
<tr id="Elffers2020" class="entry">
	<td>Elffers J, Gocht S, McCreesh C and Nordstr&ouml;m J (2020), <i>"Justifying All Differences Using Pseudo-Boolean Reasoning"</i>, In Proceedings of the AAAI Conference on Artificial Intelligence.  Vol. 34(02), pp. 1486-1494. AAAI Press.
	<p class="infolinks">[<a href="javascript:toggleInfo('Elffers2020','abstract')">Abstract</a>] [<a href="javascript:toggleInfo('Elffers2020','bibtex')">BibTeX</a>] [<a href="https://doi.org/10.1609/aaai.v34i02.5507" target="_blank">URL</a>]</p>
	</td>
</tr>
<tr id="abs_Elffers2020" class="abstract noshow">
	<td><b>Abstract</b>: Constraint programming solvers support rich global constraints and propagators, which make them both powerful and<br>hard to debug. In the Boolean satisfiability community, prooflogging is the standard solution for generating trustworthy<br>outputs, and this has become key to the social acceptability<br>of computer-generated proofs. However, reusing this technology for constraint programming requires either much weaker<br>propagation, or an impractical blowup in proof length. This<br>paper demonstrates that simple, clean, and efficient proof logging is still possible for the all-different constraint, through<br>pseudo-Boolean reasoning. We explain how such proofs can<br>be expressed and verified mechanistically, describe an implementation, and discuss the broader implications for proof logging in constraint programming.</td>
</tr>
<tr id="bib_Elffers2020" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@inproceedings{Elffers2020,
  author = {Jan Elffers and Stephan Gocht and Ciaran McCreesh and Jakob Nordstr&ouml;m},
  title = {Justifying All Differences Using Pseudo-Boolean Reasoning},
  booktitle = {Proceedings of the AAAI Conference on Artificial Intelligence},
  publisher = {AAAI Press},
  year = {2020},
  volume = {34},
  number = {02},
  pages = {1486--1494},
  url = {https://doi.org/10.1609/aaai.v34i02.5507}
}
</pre></td>
</tr>
<tr id="Gocht2020" class="entry">
	<td>Gocht S, McCreesh C and Nordström J (2020), <i>"Subgraph Isomorphism Meets Cutting Planes: Solving With Certified Solutions"</i>, In Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI-20. , pp. 1134-1140.
	<p class="infolinks">[<a href="javascript:toggleInfo('Gocht2020','abstract')">Abstract</a>] [<a href="javascript:toggleInfo('Gocht2020','bibtex')">BibTeX</a>] [<a href="https://doi.org/10.24963/ijcai.2020/158" target="_blank">URL</a>]</p>
	</td>
</tr>
<tr id="abs_Gocht2020" class="abstract noshow">
	<td><b>Abstract</b>: Modern subgraph isomorphism solvers carry out<br>sophisticated reasoning using graph invariants such<br>as degree sequences and path counts. We show that<br>all of this reasoning can be justified compactly using the cutting planes proofs studied in complexity theory. This allows us to extend a state of the<br>art subgraph isomorphism enumeration solver with<br>proof logging support, so that the solutions it outputs may be audited and verified for correctness and<br>completeness by a simple third party tool which<br>knows nothing about graph theory</td>
</tr>
<tr id="bib_Gocht2020" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@inproceedings{Gocht2020,
  author = {Gocht, Stephan and McCreesh, Ciaran and Nordström, Jakob},
  title = {Subgraph Isomorphism Meets Cutting Planes: Solving With Certified Solutions},
  booktitle = {Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI-20},
  year = {2020},
  pages = {1134--1140},
  url = {https://doi.org/10.24963/ijcai.2020/158}
}
</pre></td>
</tr>
<tr id="Gocht2019" class="entry">
	<td>Gocht S, Nordström J and Yehudayoff A (2019), <i>"On Division Versus Saturation in Pseudo-Boolean Solving"</i>, In Proceedings of the Twenty-Eighth International Joint Conference on Artificial Intelligence, IJCAI-19. , pp. 1711-1718.
	<p class="infolinks">[<a href="javascript:toggleInfo('Gocht2019','abstract')">Abstract</a>] [<a href="javascript:toggleInfo('Gocht2019','bibtex')">BibTeX</a>] [<a href="https://doi.org/10.24963/ijcai.2019/237" target="_blank">URL</a>]</p>
	</td>
</tr>
<tr id="abs_Gocht2019" class="abstract noshow">
	<td><b>Abstract</b>: The conflict-driven clause learning (CDCL) paradigm has revolutionized SAT solving over the last two decades. Extending this approach to pseudo-Boolean (PB) solvers doing 0-1 linear programming holds the promise of further exponential improvements in theory, but intriguingly such gains have not materialized in practice. Also intriguingly, most PB extensions of CDCL use not the division rule in cutting planes as defined in [Cook et al., '87] but instead the so-called saturation rule. To the best of our knowledge, there has been no study comparing the strengths of division and saturation in the context of conflict-driven PB learning, when all linear combinations of inequalities are required to cancel variables. We show that PB solvers with division instead of saturation can be exponentially stronger. In the other direction, we prove that simulating a single saturation step can require an exponential number of divisions. We also perform some experiments to see whether these phenomena can be observed in actual solvers. Our conclusion is that a careful combination of division and saturation seems to be crucial to harness more of the power of cutting planes.s</td>
</tr>
<tr id="bib_Gocht2019" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@inproceedings{Gocht2019,
  author = {Gocht, Stephan and Nordström, Jakob and Yehudayoff, Amir},
  title = {On Division Versus Saturation in Pseudo-Boolean Solving},
  booktitle = {Proceedings of the Twenty-Eighth International Joint Conference on Artificial Intelligence, IJCAI-19},
  year = {2019},
  pages = {1711--1718},
  url = {https://doi.org/10.24963/ijcai.2019/237}
}
</pre></td>
</tr>
</tbody>
</table>
<footer>
 <small>Created by <a href="http://jabref.sourceforge.net">JabRef</a> on 20/10/2021.</small>
</footer>
<!-- file generated by JabRef -->